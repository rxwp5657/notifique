// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/gin-gonic/gin"
	"github.com/go-redis/redis_rate/v10"
	"github.com/google/wire"
	"github.com/notifique/service/internal/broker"
	"github.com/notifique/service/internal/config"
	"github.com/notifique/service/internal/controllers"
	"github.com/notifique/service/internal/middleware"
	"github.com/notifique/service/internal/publish"
	"github.com/notifique/service/internal/registry/dynamodb"
	"github.com/notifique/service/internal/registry/postgres"
	"github.com/notifique/service/internal/routes"
	"github.com/notifique/service/internal/testutils/config"
	containers2 "github.com/notifique/service/internal/testutils/containers"
	"github.com/notifique/service/internal/testutils/mocks"
	"github.com/notifique/service/pkg/deployments"
	"github.com/notifique/shared/cache"
	"github.com/notifique/shared/clients"
	"github.com/notifique/shared/containers"
	"github.com/redis/go-redis/v9"
	"go.uber.org/mock/gomock"
)

// Injectors from wire.go:

func InjectPgPrioritySQS(envfile *string) (*gin.Engine, error) {
	envConfig, err := config.NewEnvConfig(envfile)
	if err != nil {
		return nil, err
	}
	client, err := cache.NewRedisClient(envConfig)
	if err != nil {
		return nil, err
	}
	registry, err := postgresresgistry.NewPostgresRegistry(envConfig)
	if err != nil {
		return nil, err
	}
	redis, err := cache.NewRedisCache(client)
	if err != nil {
		return nil, err
	}
	sqsClient, err := clients.NewSQSClient(envConfig)
	if err != nil {
		return nil, err
	}
	sqs := publish.NewSQSPublisher(sqsClient)
	priorityPublisherCfg := publish.PriorityPublisherCfg{
		Publisher:         sqs,
		Cache:             redis,
		Registry:          registry,
		QueueConfigurator: envConfig,
	}
	priority := publish.NewPriorityPublisher(priorityPublisherCfg)
	brokerRedis, err := broker.NewRedisBroker(client, envConfig)
	if err != nil {
		return nil, err
	}
	v := _wireValue
	authMiddleware, err := middleware.NewAuthMiddleware(envConfig)
	if err != nil {
		return nil, err
	}
	limiter := middleware.NewRedisLimiter(client)
	rateLimitCfg := middleware.RateLimitCfg{
		RateLimiter:  limiter,
		Configurator: envConfig,
	}
	rateLimitMiddleware, err := middleware.NewRateLimitMiddleware(rateLimitCfg)
	if err != nil {
		return nil, err
	}
	cacheCfg := middleware.CacheCfg{
		Cache:        redis,
		Configurator: envConfig,
	}
	cacheMiddleware, err := middleware.NewCacheMiddleware(cacheCfg)
	if err != nil {
		return nil, err
	}
	securityMiddleware := middleware.NewSecurityMiddleware(envConfig)
	engineConfig := routes.EngineConfig{
		RedisClient:        client,
		Registry:           registry,
		Cache:              redis,
		Publisher:          priority,
		Broker:             brokerRedis,
		EngineConfigurator: envConfig,
		Authorize:          v,
		Authenticate:       authMiddleware,
		RateLimit:          rateLimitMiddleware,
		CacheMiddleware:    cacheMiddleware,
		SecurityMiddleware: securityMiddleware,
	}
	engine, err := routes.NewEngine(engineConfig)
	if err != nil {
		return nil, err
	}
	return engine, nil
}

var (
	_wireValue = middleware.Authorize
)

func InjectPgPriorityRabbitMQ(envfile *string) (*gin.Engine, func(), error) {
	envConfig, err := config.NewEnvConfig(envfile)
	if err != nil {
		return nil, nil, err
	}
	client, err := cache.NewRedisClient(envConfig)
	if err != nil {
		return nil, nil, err
	}
	registry, err := postgresresgistry.NewPostgresRegistry(envConfig)
	if err != nil {
		return nil, nil, err
	}
	redis, err := cache.NewRedisCache(client)
	if err != nil {
		return nil, nil, err
	}
	rabbitMQ, cleanup, err := clients.NewRabbitMQClient(envConfig)
	if err != nil {
		return nil, nil, err
	}
	publishRabbitMQ := publish.NewRabbitMQPublisher(rabbitMQ)
	priorityPublisherCfg := publish.PriorityPublisherCfg{
		Publisher:         publishRabbitMQ,
		Cache:             redis,
		Registry:          registry,
		QueueConfigurator: envConfig,
	}
	priority := publish.NewPriorityPublisher(priorityPublisherCfg)
	brokerRedis, err := broker.NewRedisBroker(client, envConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	v := _wireValue
	authMiddleware, err := middleware.NewAuthMiddleware(envConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	limiter := middleware.NewRedisLimiter(client)
	rateLimitCfg := middleware.RateLimitCfg{
		RateLimiter:  limiter,
		Configurator: envConfig,
	}
	rateLimitMiddleware, err := middleware.NewRateLimitMiddleware(rateLimitCfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	cacheCfg := middleware.CacheCfg{
		Cache:        redis,
		Configurator: envConfig,
	}
	cacheMiddleware, err := middleware.NewCacheMiddleware(cacheCfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	securityMiddleware := middleware.NewSecurityMiddleware(envConfig)
	engineConfig := routes.EngineConfig{
		RedisClient:        client,
		Registry:           registry,
		Cache:              redis,
		Publisher:          priority,
		Broker:             brokerRedis,
		EngineConfigurator: envConfig,
		Authorize:          v,
		Authenticate:       authMiddleware,
		RateLimit:          rateLimitMiddleware,
		CacheMiddleware:    cacheMiddleware,
		SecurityMiddleware: securityMiddleware,
	}
	engine, err := routes.NewEngine(engineConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	return engine, func() {
		cleanup()
	}, nil
}

func InjectDynamoPrioritySQS(envfile *string) (*gin.Engine, error) {
	envConfig, err := config.NewEnvConfig(envfile)
	if err != nil {
		return nil, err
	}
	client, err := cache.NewRedisClient(envConfig)
	if err != nil {
		return nil, err
	}
	dynamodbClient, err := clients.NewDynamoDBClient(envConfig)
	if err != nil {
		return nil, err
	}
	registry := dynamoregistry.NewDynamoDBRegistry(dynamodbClient)
	redis, err := cache.NewRedisCache(client)
	if err != nil {
		return nil, err
	}
	sqsClient, err := clients.NewSQSClient(envConfig)
	if err != nil {
		return nil, err
	}
	sqs := publish.NewSQSPublisher(sqsClient)
	priorityPublisherCfg := publish.PriorityPublisherCfg{
		Publisher:         sqs,
		Cache:             redis,
		Registry:          registry,
		QueueConfigurator: envConfig,
	}
	priority := publish.NewPriorityPublisher(priorityPublisherCfg)
	brokerRedis, err := broker.NewRedisBroker(client, envConfig)
	if err != nil {
		return nil, err
	}
	v := _wireValue
	authMiddleware, err := middleware.NewAuthMiddleware(envConfig)
	if err != nil {
		return nil, err
	}
	limiter := middleware.NewRedisLimiter(client)
	rateLimitCfg := middleware.RateLimitCfg{
		RateLimiter:  limiter,
		Configurator: envConfig,
	}
	rateLimitMiddleware, err := middleware.NewRateLimitMiddleware(rateLimitCfg)
	if err != nil {
		return nil, err
	}
	cacheCfg := middleware.CacheCfg{
		Cache:        redis,
		Configurator: envConfig,
	}
	cacheMiddleware, err := middleware.NewCacheMiddleware(cacheCfg)
	if err != nil {
		return nil, err
	}
	securityMiddleware := middleware.NewSecurityMiddleware(envConfig)
	engineConfig := routes.EngineConfig{
		RedisClient:        client,
		Registry:           registry,
		Cache:              redis,
		Publisher:          priority,
		Broker:             brokerRedis,
		EngineConfigurator: envConfig,
		Authorize:          v,
		Authenticate:       authMiddleware,
		RateLimit:          rateLimitMiddleware,
		CacheMiddleware:    cacheMiddleware,
		SecurityMiddleware: securityMiddleware,
	}
	engine, err := routes.NewEngine(engineConfig)
	if err != nil {
		return nil, err
	}
	return engine, nil
}

func InjectDynamoPriorityRabbitMQ(envfile *string) (*gin.Engine, func(), error) {
	envConfig, err := config.NewEnvConfig(envfile)
	if err != nil {
		return nil, nil, err
	}
	client, err := cache.NewRedisClient(envConfig)
	if err != nil {
		return nil, nil, err
	}
	dynamodbClient, err := clients.NewDynamoDBClient(envConfig)
	if err != nil {
		return nil, nil, err
	}
	registry := dynamoregistry.NewDynamoDBRegistry(dynamodbClient)
	redis, err := cache.NewRedisCache(client)
	if err != nil {
		return nil, nil, err
	}
	rabbitMQ, cleanup, err := clients.NewRabbitMQClient(envConfig)
	if err != nil {
		return nil, nil, err
	}
	publishRabbitMQ := publish.NewRabbitMQPublisher(rabbitMQ)
	priorityPublisherCfg := publish.PriorityPublisherCfg{
		Publisher:         publishRabbitMQ,
		Cache:             redis,
		Registry:          registry,
		QueueConfigurator: envConfig,
	}
	priority := publish.NewPriorityPublisher(priorityPublisherCfg)
	brokerRedis, err := broker.NewRedisBroker(client, envConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	v := _wireValue
	authMiddleware, err := middleware.NewAuthMiddleware(envConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	limiter := middleware.NewRedisLimiter(client)
	rateLimitCfg := middleware.RateLimitCfg{
		RateLimiter:  limiter,
		Configurator: envConfig,
	}
	rateLimitMiddleware, err := middleware.NewRateLimitMiddleware(rateLimitCfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	cacheCfg := middleware.CacheCfg{
		Cache:        redis,
		Configurator: envConfig,
	}
	cacheMiddleware, err := middleware.NewCacheMiddleware(cacheCfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	securityMiddleware := middleware.NewSecurityMiddleware(envConfig)
	engineConfig := routes.EngineConfig{
		RedisClient:        client,
		Registry:           registry,
		Cache:              redis,
		Publisher:          priority,
		Broker:             brokerRedis,
		EngineConfigurator: envConfig,
		Authorize:          v,
		Authenticate:       authMiddleware,
		RateLimit:          rateLimitMiddleware,
		CacheMiddleware:    cacheMiddleware,
		SecurityMiddleware: securityMiddleware,
	}
	engine, err := routes.NewEngine(engineConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	return engine, func() {
		cleanup()
	}, nil
}

func InjectPgSQSPriorityIntegrationTest(ctx context.Context) (*PgSQSPriorityIntegrationTest, func(), error) {
	postgres, cleanup, err := containers.NewPostgresContainer(ctx)
	if err != nil {
		return nil, nil, err
	}
	sqsPriority, cleanup2, err := containers2.NewSQSPriorityContainer(ctx)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	redis, cleanup3, err := containers.NewRedisContainer(ctx)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	registry, err := postgresresgistry.NewPostgresRegistry(postgres)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	client, err := clients.NewSQSClient(sqsPriority)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	sqs := publish.NewSQSPublisher(client)
	redisClient, err := cache.NewRedisClient(redis)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	cacheRedis, err := cache.NewRedisCache(redisClient)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	priorityPublisherCfg := publish.PriorityPublisherCfg{
		Publisher:         sqs,
		Cache:             cacheRedis,
		Registry:          registry,
		QueueConfigurator: sqsPriority,
	}
	priority := publish.NewPriorityPublisher(priorityPublisherCfg)
	pgSQSPriorityIntegrationTest := &PgSQSPriorityIntegrationTest{
		Postgres:  postgres,
		SQS:       sqsPriority,
		Redis:     redis,
		Registry:  registry,
		Publisher: priority,
		Cache:     cacheRedis,
	}
	return pgSQSPriorityIntegrationTest, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

func InjectPgRabbitMQPriorityIntegrationTest(ctx context.Context) (*PgRabbitMQPriorityIntegrationTest, func(), error) {
	postgres, cleanup, err := containers.NewPostgresContainer(ctx)
	if err != nil {
		return nil, nil, err
	}
	rabbitMQPriority, cleanup2, err := containers2.NewRabbitMQPriorityContainer(ctx)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	redis, cleanup3, err := containers.NewRedisContainer(ctx)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	registry, err := postgresresgistry.NewPostgresRegistry(postgres)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	rabbitMQ, cleanup4, err := clients.NewRabbitMQClient(rabbitMQPriority)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	publishRabbitMQ := publish.NewRabbitMQPublisher(rabbitMQ)
	client, err := cache.NewRedisClient(redis)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	cacheRedis, err := cache.NewRedisCache(client)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	priorityPublisherCfg := publish.PriorityPublisherCfg{
		Publisher:         publishRabbitMQ,
		Cache:             cacheRedis,
		Registry:          registry,
		QueueConfigurator: rabbitMQPriority,
	}
	priority := publish.NewPriorityPublisher(priorityPublisherCfg)
	pgRabbitMQPriorityIntegrationTest := &PgRabbitMQPriorityIntegrationTest{
		Postgres:  postgres,
		RabbitMQ:  rabbitMQPriority,
		Redis:     redis,
		Registry:  registry,
		Publisher: priority,
		Cache:     cacheRedis,
	}
	return pgRabbitMQPriorityIntegrationTest, func() {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

func InjectMockedBackend(ctx context.Context, mockController *gomock.Controller) (*MockedBackend, error) {
	mockDistributionRegistry := mocks.NewMockDistributionRegistry(mockController)
	mockUserRegistry := mocks.NewMockUserRegistry(mockController)
	mockNotificationRegistry := mocks.NewMockNotificationRegistry(mockController)
	mockNotificationTemplateRegistry := mocks.NewMockNotificationTemplateRegistry(mockController)
	mockedRegistry := mocks.NewMockedRegistry(mockDistributionRegistry, mockUserRegistry, mockNotificationRegistry, mockNotificationTemplateRegistry)
	mockNotificationPublisher := mocks.NewMockNotificationPublisher(mockController)
	mockUserNotificationBroker := mocks.NewMockUserNotificationBroker(mockController)
	mockCache := mocks.NewMockCache(mockController)
	client := _wireClientValue
	testEngineConfigurator := config_test.NewTestVersionConfigurator()
	v := _wireValue2
	authMiddleware := mocks.NewTestAuthMiddleware()
	rateLimitMiddleware := mocks.NewTestRateLimitMiddleware()
	cacheMiddleware := mocks.NewTestCacheMiddleware()
	securityMiddleware := mocks.NewTestSecurityMiddleware()
	engineConfig := routes.EngineConfig{
		RedisClient:        client,
		Registry:           mockedRegistry,
		Cache:              mockCache,
		Publisher:          mockNotificationPublisher,
		Broker:             mockUserNotificationBroker,
		EngineConfigurator: testEngineConfigurator,
		Authorize:          v,
		Authenticate:       authMiddleware,
		RateLimit:          rateLimitMiddleware,
		CacheMiddleware:    cacheMiddleware,
		SecurityMiddleware: securityMiddleware,
	}
	engine, err := routes.NewEngine(engineConfig)
	if err != nil {
		return nil, err
	}
	mockedBackend := &MockedBackend{
		Registry:  mockedRegistry,
		Publisher: mockNotificationPublisher,
		Broker:    mockUserNotificationBroker,
		Cache:     mockCache,
		Engine:    engine,
	}
	return mockedBackend, nil
}

var (
	_wireClientValue = (*redis.Client)(nil)
	_wireValue2      = middleware.Authorize
)

func InjectRabbitMQPriorityDeployer(envfile *string) (*deployments.RabbitMQPriorityDeployer, func(), error) {
	envConfig, err := config.NewEnvConfig(envfile)
	if err != nil {
		return nil, nil, err
	}
	rabbitMQPriorityDeployer, cleanup, err := deployments.NewRabbitMQPriorityDeployer(envConfig)
	if err != nil {
		return nil, nil, err
	}
	return rabbitMQPriorityDeployer, func() {
		cleanup()
	}, nil
}

func InjectSQSPriorityDeployer(envfile *string) (*deployments.SQSPriorityDeployer, func(), error) {
	envConfig, err := config.NewEnvConfig(envfile)
	if err != nil {
		return nil, nil, err
	}
	sqsPriorityDeployer, err := deployments.NewSQSPriorityDeployer(envConfig)
	if err != nil {
		return nil, nil, err
	}
	return sqsPriorityDeployer, func() {
	}, nil
}

// wire.go:

type PostgresMockedPubIntegrationTest struct {
	Postgres  *containers.Postgres
	Redis     *containers.Redis
	Registry  *postgresresgistry.Registry
	Publisher *mocks.MockNotificationPublisher
	Broker    *broker.Redis
	Engine    *gin.Engine
}

type DynamoMockedPubIntegrationTest struct {
	Dynamo    *containers.Dynamo
	Redis     *containers.Redis
	Registry  *dynamoregistry.Registry
	Publisher *mocks.MockNotificationPublisher
	Broker    *broker.Redis
	Engine    *gin.Engine
}

type PgSQSPriorityIntegrationTest struct {
	Postgres  *containers.Postgres
	SQS       *containers2.SQSPriority
	Redis     *containers.Redis
	Registry  *postgresresgistry.Registry
	Publisher *publish.Priority
	Cache     *cache.Redis
}

type PgRabbitMQPriorityIntegrationTest struct {
	Postgres  *containers.Postgres
	RabbitMQ  *containers2.RabbitMQPriority
	Redis     *containers.Redis
	Registry  *postgresresgistry.Registry
	Publisher *publish.Priority
	Cache     *cache.Redis
}

type DynamoSQSPriorityIntegrationTest struct {
	Dynamo    *containers.Dynamo
	SQS       *containers2.SQSPriority
	Registry  *dynamoregistry.Registry
	Publisher *publish.Priority
}

type DynamoRabbitMQPriorityIntegrationTest struct {
	Dynamo    *containers.Dynamo
	RabbitMQ  *containers2.RabbitMQPriority
	Registry  *dynamoregistry.Registry
	Publisher *publish.Priority
}

type MockedBackend struct {
	Registry  *mocks.MockedRegistry
	Publisher *mocks.MockNotificationPublisher
	Broker    *mocks.MockUserNotificationBroker
	Cache     *mocks.MockCache
	Engine    *gin.Engine
}

var DynamoSet = wire.NewSet(clients.NewDynamoDBClient, dynamoregistry.NewDynamoDBRegistry, wire.Bind(new(dynamoregistry.DynamoDBAPI), new(*dynamodb.Client)), wire.Bind(new(routes.Registry), new(*dynamoregistry.Registry)), wire.Bind(new(controllers.NotificationRegistry), new(*dynamoregistry.Registry)))

var PostgresSet = wire.NewSet(postgresresgistry.NewPostgresRegistry, wire.Bind(new(routes.Registry), new(*postgresresgistry.Registry)), wire.Bind(new(controllers.NotificationRegistry), new(*postgresresgistry.Registry)))

var SQSPublisherSet = wire.NewSet(clients.NewSQSClient, publish.NewSQSPublisher, wire.Bind(new(publish.SQSAPI), new(*sqs.Client)), wire.Bind(new(publish.Publisher), new(*publish.SQS)))

var RabbitMQPublisherSet = wire.NewSet(clients.NewRabbitMQClient, publish.NewRabbitMQPublisher, wire.Bind(new(publish.RabbitMQAPI), new(*clients.RabbitMQ)), wire.Bind(new(publish.Publisher), new(*publish.RabbitMQ)))

var PriorityPublisherCfgSet = wire.NewSet(wire.Struct(new(publish.PriorityPublisherCfg), "*"))

var RedisSet = wire.NewSet(cache.NewRedisClient, wire.Bind(new(cache.CacheRedisApi), new(*redis.Client)), wire.Bind(new(broker.BrokerRedisApi), new(*redis.Client)))

var RedisCacheSet = wire.NewSet(cache.NewRedisCache, wire.Bind(new(cache.Cache), new(*cache.Redis)))

var RedisUserNotificationBrokerSet = wire.NewSet(broker.NewRedisBroker, wire.Bind(new(controllers.UserNotificationBroker), new(*broker.Redis)))

var PrioritySet = wire.NewSet(
	PriorityPublisherCfgSet, publish.NewPriorityPublisher, wire.Bind(new(controllers.NotificationPublisher), new(*publish.Priority)),
)

var PostgresContainerSet = wire.NewSet(containers.NewPostgresContainer, wire.Bind(new(clients.PostgresConfigurator), new(*containers.Postgres)))

var SQSPriorityContainerSet = wire.NewSet(containers2.NewSQSPriorityContainer, wire.Bind(new(clients.SQSConfigurator), new(*containers2.SQSPriority)), wire.Bind(new(publish.PriorityQueueConfigurator), new(*containers2.SQSPriority)))

var RabbitMQPriorityContainerSet = wire.NewSet(containers2.NewRabbitMQPriorityContainer, wire.Bind(new(clients.RabbitMQConfigurator), new(*containers2.RabbitMQPriority)), wire.Bind(new(publish.PriorityQueueConfigurator), new(*containers2.RabbitMQPriority)))

var DynamoContainerSet = wire.NewSet(containers.NewDynamoContainer, wire.Bind(new(clients.DynamoConfigurator), new(*containers.Dynamo)))

var RedisContainerSet = wire.NewSet(containers.NewRedisContainer, wire.Bind(new(cache.RedisConfigurator), new(*containers.Redis)), wire.Bind(new(broker.BrokerConfigurator), new(*containers.Redis)))

var RedisRateSet = wire.NewSet(middleware.NewRedisLimiter, wire.Bind(new(middleware.RateLimiter), new(*redis_rate.Limiter)))

var MiddlewareSet = wire.NewSet(
	RedisRateSet, wire.Struct(new(middleware.RateLimitCfg), "*"), wire.Struct(new(middleware.CacheCfg), "*"), middleware.NewSecurityMiddleware, middleware.NewRateLimitMiddleware, middleware.NewCacheMiddleware, middleware.NewAuthMiddleware, wire.Value(middleware.Authorize),
)

var MockedPublihserSet = wire.NewSet(mocks.NewMockNotificationPublisher, wire.Bind(new(controllers.NotificationPublisher), new(*mocks.MockNotificationPublisher)))

var MockedDistributionRegistrySet = wire.NewSet(mocks.NewMockDistributionRegistry, wire.Bind(new(controllers.DistributionRegistry), new(*mocks.MockDistributionRegistry)))

var MockedUserRegistrySet = wire.NewSet(mocks.NewMockUserRegistry, wire.Bind(new(controllers.UserRegistry), new(*mocks.MockUserRegistry)))

var MockedNotificationRegistrySet = wire.NewSet(mocks.NewMockNotificationRegistry, wire.Bind(new(controllers.NotificationRegistry), new(*mocks.MockNotificationRegistry)))

var MockedNotificationTemplateRegistrySet = wire.NewSet(mocks.NewMockNotificationTemplateRegistry, wire.Bind(new(controllers.NotificationTemplateRegistry), new(*mocks.MockNotificationTemplateRegistry)))

var MockedUserNotificationBroker = wire.NewSet(mocks.NewMockUserNotificationBroker, wire.Bind(new(controllers.UserNotificationBroker), new(*mocks.MockUserNotificationBroker)))

var MockedRegistrySet = wire.NewSet(
	MockedDistributionRegistrySet,
	MockedUserRegistrySet,
	MockedNotificationRegistrySet,
	MockedNotificationTemplateRegistrySet, mocks.NewMockedRegistry, wire.Bind(new(routes.Registry), new(*mocks.MockedRegistry)),
)

var MockedMiddlewareSet = wire.NewSet(mocks.NewTestAuthMiddleware, mocks.NewTestCacheMiddleware, mocks.NewTestSecurityMiddleware, mocks.NewTestRateLimitMiddleware, wire.Value(middleware.Authorize))

var TestVersionConfiguratorSet = wire.NewSet(config_test.NewTestVersionConfigurator, wire.Bind(new(routes.EngineConfigurator), new(config_test.TestEngineConfigurator)))

var EnvConfigSet = wire.NewSet(config.NewEnvConfig, wire.Bind(new(clients.PostgresConfigurator), new(*config.EnvConfig)), wire.Bind(new(clients.DynamoConfigurator), new(*config.EnvConfig)), wire.Bind(new(publish.PriorityQueueConfigurator), new(*config.EnvConfig)), wire.Bind(new(clients.SQSConfigurator), new(*config.EnvConfig)), wire.Bind(new(clients.RabbitMQConfigurator), new(*config.EnvConfig)), wire.Bind(new(publish.RabbitMQPriorityConfigurator), new(*config.EnvConfig)), wire.Bind(new(publish.SQSPriorityConfigurator), new(*config.EnvConfig)), wire.Bind(new(cache.RedisConfigurator), new(*config.EnvConfig)), wire.Bind(new(broker.BrokerConfigurator), new(*config.EnvConfig)), wire.Bind(new(routes.EngineConfigurator), new(*config.EnvConfig)), wire.Bind(new(middleware.AuthConfigurator), new(*config.EnvConfig)), wire.Bind(new(middleware.CacheConfigurator), new(*config.EnvConfig)), wire.Bind(new(middleware.RateLimitConfigurator), new(*config.EnvConfig)), wire.Bind(new(middleware.SecurityConfigurator), new(*config.EnvConfig)))

var MockedCacheSet = wire.NewSet(mocks.NewMockCache, wire.Bind(new(cache.Cache), new(*mocks.MockCache)))

var EngineConfigSet = wire.NewSet(wire.Struct(new(routes.EngineConfig), "*"))
