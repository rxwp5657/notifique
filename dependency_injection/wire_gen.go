// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package dependencyinjection

import (
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
	"github.com/notifique/controllers"
	"github.com/notifique/internal/publisher"
	"github.com/notifique/internal/storage/dynamodb"
	storage2 "github.com/notifique/internal/storage/postgres"
	"github.com/notifique/routes"
	"github.com/notifique/test/containers"
)

// Injectors from wire.go:

func InjectDynamoSQSEngine(dynamoEndpoint *storage.DynamoEndpoint, sqsEndpoint *publisher.SQSEndpoint, urls publisher.SQSEndpoints) (*gin.Engine, error) {
	client, err := storage.MakeDynamoDBClient(dynamoEndpoint)
	if err != nil {
		return nil, err
	}
	dynamoDBStorage := storage.MakeDynamoDBStorage(client)
	sqsClient, err := publisher.MakeSQSClient(sqsEndpoint)
	if err != nil {
		return nil, err
	}
	sqsConfig := MakeSQSConfig(sqsClient, urls)
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(dynamoDBStorage, sqsPublisher)
	return engine, nil
}

func InjectPostgresSQSEngine(postgresUrl storage2.PostgresURL, sqsEndpoint *publisher.SQSEndpoint, urls publisher.SQSEndpoints) (*gin.Engine, error) {
	postgresStorage, err := storage2.MakePostgresStorage(postgresUrl)
	if err != nil {
		return nil, err
	}
	client, err := publisher.MakeSQSClient(sqsEndpoint)
	if err != nil {
		return nil, err
	}
	sqsConfig := MakeSQSConfig(client, urls)
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(postgresStorage, sqsPublisher)
	return engine, nil
}

func InjectPostgresSQSContainerTesting(ctx context.Context) (*PostgresSQSIntegrationTest, error) {
	postgresContainer, err := containers.MakePostgresContainer(ctx)
	if err != nil {
		return nil, err
	}
	sqsContainer, err := containers.MakeSQSContainer(ctx)
	if err != nil {
		return nil, err
	}
	postgresURL, err := MakePostgresUrl(postgresContainer)
	if err != nil {
		return nil, err
	}
	postgresStorage, err := storage2.MakePostgresStorage(postgresURL)
	if err != nil {
		return nil, err
	}
	sqsEndpoint, err := MakeSQSEndpoint(sqsContainer)
	if err != nil {
		return nil, err
	}
	client, err := publisher.MakeSQSClient(sqsEndpoint)
	if err != nil {
		return nil, err
	}
	sqsEndpoints, err := MakeSQSEndpoints(sqsContainer)
	if err != nil {
		return nil, err
	}
	sqsConfig := MakeSQSConfig(client, sqsEndpoints)
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(postgresStorage, sqsPublisher)
	postgresSQSIntegrationTest := &PostgresSQSIntegrationTest{
		PostgresContainer: postgresContainer,
		SQSContainer:      sqsContainer,
		Storage:           postgresStorage,
		Publisher:         sqsPublisher,
		Engine:            engine,
	}
	return postgresSQSIntegrationTest, nil
}

func InjectDynamoSQSContainerTesting(ctx context.Context) (*DynamoSQSIntegrationTest, error) {
	dynamoContainer, err := containers.MakeDynamoContainer(ctx)
	if err != nil {
		return nil, err
	}
	sqsContainer, err := containers.MakeSQSContainer(ctx)
	if err != nil {
		return nil, err
	}
	dynamoEndpoint, err := MakeDynamoEndpoint(dynamoContainer)
	if err != nil {
		return nil, err
	}
	client, err := storage.MakeDynamoDBClient(dynamoEndpoint)
	if err != nil {
		return nil, err
	}
	dynamoDBStorage := storage.MakeDynamoDBStorage(client)
	sqsEndpoint, err := MakeSQSEndpoint(sqsContainer)
	if err != nil {
		return nil, err
	}
	sqsClient, err := publisher.MakeSQSClient(sqsEndpoint)
	if err != nil {
		return nil, err
	}
	sqsEndpoints, err := MakeSQSEndpoints(sqsContainer)
	if err != nil {
		return nil, err
	}
	sqsConfig := MakeSQSConfig(sqsClient, sqsEndpoints)
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(dynamoDBStorage, sqsPublisher)
	dynamoSQSIntegrationTest := &DynamoSQSIntegrationTest{
		DynamoContainer: dynamoContainer,
		SQSContainer:    sqsContainer,
		DynamoDBStorage: dynamoDBStorage,
		SQSPublisher:    sqsPublisher,
		Engine:          engine,
	}
	return dynamoSQSIntegrationTest, nil
}

// wire.go:

type Storage interface {
	controllers.NotificationStorage
	controllers.UserStorage
	controllers.DistributionListStorage
}

var DynamoSet = wire.NewSet(storage.MakeDynamoDBClient, storage.MakeDynamoDBStorage, wire.Bind(new(storage.DynamoDBAPI), new(*dynamodb.Client)), wire.Bind(new(Storage), new(*storage.DynamoDBStorage)))

var PostgresSet = wire.NewSet(storage2.MakePostgresStorage, wire.Bind(new(Storage), new(*storage2.PostgresStorage)))

var SQSSet = wire.NewSet(publisher.MakeSQSClient, MakeSQSConfig, publisher.MakeSQSPublisher, wire.Bind(new(publisher.SQSAPI), new(*sqs.Client)), wire.Bind(new(controllers.NotificationPublisher), new(*publisher.SQSPublisher)))

var PostgresContainerSet = wire.NewSet(containers.MakePostgresContainer, MakePostgresUrl)

var SQSContainerSet = wire.NewSet(containers.MakeSQSContainer, MakeSQSEndpoint,
	MakeSQSEndpoints,
)

var DynamoContainerSet = wire.NewSet(containers.MakeDynamoContainer, MakeDynamoEndpoint)

type PostgresSQSIntegrationTest struct {
	PostgresContainer *containers.PostgresContainer
	SQSContainer      *containers.SQSContainer
	Storage           *storage2.PostgresStorage
	Publisher         *publisher.SQSPublisher
	Engine            *gin.Engine
}

func (app *PostgresSQSIntegrationTest) Cleanup() error {
	if err := app.PostgresContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to cleanup postgres container - %w", err)
	}

	if err := app.SQSContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to terminate sqs container - %w", err)
	}

	return nil
}

type DynamoSQSIntegrationTest struct {
	DynamoContainer *containers.DynamoContainer
	SQSContainer    *containers.SQSContainer
	DynamoDBStorage *storage.DynamoDBStorage
	SQSPublisher    *publisher.SQSPublisher
	Engine          *gin.Engine
}

func (app *DynamoSQSIntegrationTest) Cleanup() error {
	if err := app.DynamoContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to cleanup dynamo container - %w", err)
	}

	if err := app.SQSContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to terminate sqs container - %w", err)
	}

	return nil
}

func MakePostgresUrl(container *containers.PostgresContainer) (storage2.PostgresURL, error) {
	if container == nil {
		return "", fmt.Errorf("postgres container is null")
	}
	return (storage2.PostgresURL)(container.URI), nil
}

func MakeSQSEndpoint(container *containers.SQSContainer) (*publisher.SQSEndpoint, error) {

	if container == nil {
		return nil, fmt.Errorf("sqs container is null")
	}

	return (*publisher.SQSEndpoint)(&container.URI), nil
}

func MakeSQSEndpoints(container *containers.SQSContainer) (publisher.SQSEndpoints, error) {

	if container == nil {
		return publisher.SQSEndpoints{}, fmt.Errorf("sqs container is null")
	}

	return container.SQSEndpoints, nil
}

func MakeDynamoEndpoint(container *containers.DynamoContainer) (*storage.DynamoEndpoint, error) {

	if container == nil {
		return nil, fmt.Errorf("sqs container is null")
	}

	return (*storage.DynamoEndpoint)(&container.URI), nil
}

func MakeSQSConfig(client publisher.SQSAPI, urls publisher.SQSEndpoints) publisher.SQSConfig {
	return publisher.SQSConfig{
		Client: client,
		Urls:   urls,
	}
}

func MakeEngine(storage3 Storage, pub controllers.NotificationPublisher) *gin.Engine {

	r := gin.Default()
	routes.SetupNotificationRoutes(r, storage3, pub)
	routes.SetupDistributionListRoutes(r, storage3)
	routes.SetupUsersRoutes(r, storage3)

	return r
}
