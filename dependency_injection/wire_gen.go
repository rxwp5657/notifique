// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package dependencyinjection

import (
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
	"github.com/notifique/controllers"
	deployments2 "github.com/notifique/deployments/rabbitmq"
	"github.com/notifique/deployments/sqs"
	"github.com/notifique/internal/publisher"
	"github.com/notifique/internal/storage/dynamodb"
	storage2 "github.com/notifique/internal/storage/postgres"
	"github.com/notifique/routes"
	"github.com/notifique/test/containers"
)

// Injectors from wire.go:

func InjectDynamoSQSEngine(cfg ConfigLoader) (*gin.Engine, error) {
	dynamoClientConfig := MakeDynamoClientConfig(cfg)
	client, err := storage.MakeDynamoDBClient(dynamoClientConfig)
	if err != nil {
		return nil, err
	}
	dynamoDBStorage := storage.MakeDynamoDBStorage(client)
	sqsConfig, err := MakeSQSConfig(cfg)
	if err != nil {
		return nil, err
	}
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(dynamoDBStorage, sqsPublisher)
	return engine, nil
}

func InjectPostgresSQSEngine(cfg ConfigLoader) (*gin.Engine, error) {
	postgresURL, err := GetPostgresUrl(cfg)
	if err != nil {
		return nil, err
	}
	postgresStorage, err := storage2.MakePostgresStorage(postgresURL)
	if err != nil {
		return nil, err
	}
	sqsConfig, err := MakeSQSConfig(cfg)
	if err != nil {
		return nil, err
	}
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(postgresStorage, sqsPublisher)
	return engine, nil
}

func InjectDynamoRabbitMQPriorityQueueEngine(cfg ConfigLoader) (*gin.Engine, error) {
	dynamoClientConfig := MakeDynamoClientConfig(cfg)
	client, err := storage.MakeDynamoDBClient(dynamoClientConfig)
	if err != nil {
		return nil, err
	}
	dynamoDBStorage := storage.MakeDynamoDBStorage(client)
	rabbitMQURL, err := GetRabbitMQUrl(cfg)
	if err != nil {
		return nil, err
	}
	rabbitMQClient, err := publisher.MakeRabbitMQClient(rabbitMQURL)
	if err != nil {
		return nil, err
	}
	priorityQueues := GetRabbitMQQueues(cfg)
	rabbitMQPriorityPublisherConfig := MakeRabbitMKPriorityConfig(rabbitMQClient, priorityQueues)
	rabbitMQPriorityPublisher := publisher.MakeRabbitMQPriorityPub(rabbitMQPriorityPublisherConfig)
	engine := MakeEngine(dynamoDBStorage, rabbitMQPriorityPublisher)
	return engine, nil
}

func InjectPostgresRabbitMQPriorityQueueEngine(cfg ConfigLoader) (*gin.Engine, error) {
	postgresURL, err := GetPostgresUrl(cfg)
	if err != nil {
		return nil, err
	}
	postgresStorage, err := storage2.MakePostgresStorage(postgresURL)
	if err != nil {
		return nil, err
	}
	rabbitMQURL, err := GetRabbitMQUrl(cfg)
	if err != nil {
		return nil, err
	}
	rabbitMQClient, err := publisher.MakeRabbitMQClient(rabbitMQURL)
	if err != nil {
		return nil, err
	}
	priorityQueues := GetRabbitMQQueues(cfg)
	rabbitMQPriorityPublisherConfig := MakeRabbitMKPriorityConfig(rabbitMQClient, priorityQueues)
	rabbitMQPriorityPublisher := publisher.MakeRabbitMQPriorityPub(rabbitMQPriorityPublisherConfig)
	engine := MakeEngine(postgresStorage, rabbitMQPriorityPublisher)
	return engine, nil
}

func InjectPostgresSQSContainerTesting(ctx context.Context) (*PostgresSQSIntegrationTest, error) {
	postgresContainer, err := containers.MakePostgresContainer(ctx)
	if err != nil {
		return nil, err
	}
	sqsContainer, err := containers.MakeSQSContainer(ctx)
	if err != nil {
		return nil, err
	}
	postgresURL, err := MakePostgresUrlFromContainer(postgresContainer)
	if err != nil {
		return nil, err
	}
	postgresStorage, err := storage2.MakePostgresStorage(postgresURL)
	if err != nil {
		return nil, err
	}
	sqsConfig, err := MakeSQSConfigFromContainer(sqsContainer)
	if err != nil {
		return nil, err
	}
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(postgresStorage, sqsPublisher)
	postgresSQSIntegrationTest := &PostgresSQSIntegrationTest{
		PostgresContainer: postgresContainer,
		SQSContainer:      sqsContainer,
		Storage:           postgresStorage,
		Publisher:         sqsPublisher,
		Engine:            engine,
	}
	return postgresSQSIntegrationTest, nil
}

func InjectDynamoSQSContainerTesting(ctx context.Context) (*DynamoSQSIntegrationTest, error) {
	dynamoContainer, err := containers.MakeDynamoContainer(ctx)
	if err != nil {
		return nil, err
	}
	sqsContainer, err := containers.MakeSQSContainer(ctx)
	if err != nil {
		return nil, err
	}
	dynamoClientConfig, err := MakeDynamoConfigFromContainer(dynamoContainer)
	if err != nil {
		return nil, err
	}
	client, err := storage.MakeDynamoDBClient(dynamoClientConfig)
	if err != nil {
		return nil, err
	}
	dynamoDBStorage := storage.MakeDynamoDBStorage(client)
	sqsConfig, err := MakeSQSConfigFromContainer(sqsContainer)
	if err != nil {
		return nil, err
	}
	sqsPublisher := publisher.MakeSQSPublisher(sqsConfig)
	engine := MakeEngine(dynamoDBStorage, sqsPublisher)
	dynamoSQSIntegrationTest := &DynamoSQSIntegrationTest{
		DynamoContainer: dynamoContainer,
		SQSContainer:    sqsContainer,
		Storage:         dynamoDBStorage,
		Publisher:       sqsPublisher,
		Engine:          engine,
	}
	return dynamoSQSIntegrationTest, nil
}

func InjectPostgresRabbitMQPriorityContainerTesting(ctx context.Context) (*PostgresRabbitMQPriorityIntegrationTest, error) {
	postgresContainer, err := containers.MakePostgresContainer(ctx)
	if err != nil {
		return nil, err
	}
	rabbitMQPriorityDeployer := containers.MakeRabbitMQPriorityDeployer()
	rabbitMQContainer, err := containers.MakeRabbitMQContainer(ctx, rabbitMQPriorityDeployer)
	if err != nil {
		return nil, err
	}
	rabbitMQClient, err := containers.MakeRabbitMQClient(rabbitMQContainer)
	if err != nil {
		return nil, err
	}
	rabbitMQPriorityPublisher, err := containers.MakeRabbitMQPriorityPub(rabbitMQClient, rabbitMQPriorityDeployer)
	if err != nil {
		return nil, err
	}
	postgresURL, err := MakePostgresUrlFromContainer(postgresContainer)
	if err != nil {
		return nil, err
	}
	postgresStorage, err := storage2.MakePostgresStorage(postgresURL)
	if err != nil {
		return nil, err
	}
	engine := MakeEngine(postgresStorage, rabbitMQPriorityPublisher)
	postgresRabbitMQPriorityIntegrationTest := &PostgresRabbitMQPriorityIntegrationTest{
		PostgresContainer: postgresContainer,
		RabbitMQContainer: rabbitMQContainer,
		RabbitMQClient:    rabbitMQClient,
		RabbitMQPubliser:  rabbitMQPriorityPublisher,
		Storage:           postgresStorage,
		Engine:            engine,
	}
	return postgresRabbitMQPriorityIntegrationTest, nil
}

func InjectSQSPriorityQueueDeployment(cfg ConfigLoader) (*SQSPriorityDeployment, error) {
	client, err := MakeSQSClient(cfg)
	if err != nil {
		return nil, err
	}
	priorityQueues := GetSQSPriorityQueueNames(cfg)
	sqsPriorityDeployment := MakeSQSPriorityQueueDeployment(client, priorityQueues)
	return sqsPriorityDeployment, nil
}

func InjectRabbitMQPriorityQueueDeployment(cfg ConfigLoader) (*RabbitMQPriorityDeployment, error) {
	rabbitMQURL, err := GetRabbitMQUrl(cfg)
	if err != nil {
		return nil, err
	}
	rabbitMQClient, err := publisher.MakeRabbitMQClient(rabbitMQURL)
	if err != nil {
		return nil, err
	}
	priorityQueues := GetRabbitMQQueues(cfg)
	rabbitMQPriorityDeployment := MakeRabbitMQDeployment(rabbitMQClient, priorityQueues)
	return rabbitMQPriorityDeployment, nil
}

// wire.go:

const (
	SQS_BASE_ENDPOINT              = "SQS_BASE_ENDPOINT"
	SQS_REGION                     = "SQS_REGION"
	DYNAMO_BASE_ENDPOINT           = "DYNAMO_BASE_ENDPOINT"
	DYNAMO_REGION                  = "DYNAMO_REGION"
	SQS_PRIORITY_LOW_NAME          = "SQS_PRIORITY_LOW_NAME"
	SQS_PRIORITY_MEDIUM_NAME       = "SQS_PRIORITY_MEDIUM_NAME"
	SQS_PRIORITY_HIGH_NAME         = "SQS_PRIORITY_HIGH_NAME"
	SQS_PRIORITY_LOW_URL           = "SQS_LOW_URL"
	SQS_PRIORITY_MEDIUM_URL        = "SQS_MEDIUM_URL"
	SQS_PRIORITY_HIGH_URL          = "SQS_HIGH_URL"
	RABBITMQ_URL                   = "RABBITMQ_URL"
	RABBITMQ_PRIORITY_LOW_QUEUE    = "RABBITMQ_PRIORITY_LOW_QUEUE"
	RABBITMQ_PRIORITY_MEDIUM_QUEUE = "RABBITMQ_PRIORITY_MEDIUM_QUEUE"
	RABBITMQ_PRIORITY_HIGH_QUEUE   = "RABBITMQ_PRIORITY_HIGH_QUEUE"
	POSTGRES_URL                   = "POSTGRES_URL"
)

type Storage interface {
	controllers.NotificationStorage
	controllers.UserStorage
	controllers.DistributionListStorage
}

type ConfigLoader interface {
	GetConfigValue(key string) (string, bool)
}

var DynamoSet = wire.NewSet(storage.MakeDynamoDBClient, storage.MakeDynamoDBStorage, wire.Bind(new(storage.DynamoDBAPI), new(*dynamodb.Client)), wire.Bind(new(Storage), new(*storage.DynamoDBStorage)))

var PostgresSet = wire.NewSet(storage2.MakePostgresStorage, wire.Bind(new(Storage), new(*storage2.PostgresStorage)))

var SQSSet = wire.NewSet(publisher.MakeSQSClient, publisher.MakeSQSPublisher, wire.Bind(new(publisher.SQSAPI), new(*sqs.Client)), wire.Bind(new(controllers.NotificationPublisher), new(*publisher.SQSPublisher)))

var PostgresContainerSet = wire.NewSet(containers.MakePostgresContainer, MakePostgresUrlFromContainer)

var SQSContainerSet = wire.NewSet(containers.MakeSQSContainer, MakeSQSConfigFromContainer)

var RabbitMQPrioritySet = wire.NewSet(
	GetRabbitMQUrl,
	GetRabbitMQQueues, publisher.MakeRabbitMQClient, MakeRabbitMKPriorityConfig, publisher.MakeRabbitMQPriorityPub, wire.Bind(new(controllers.NotificationPublisher), new(*publisher.RabbitMQPriorityPublisher)),
)

var DynamoContainerSet = wire.NewSet(containers.MakeDynamoContainer, MakeDynamoConfigFromContainer)

var RabbitMQPriorityContainerSet = wire.NewSet(containers.MakeRabbitMQPriorityDeployer, containers.MakeRabbitMQContainer, containers.MakeRabbitMQClient, containers.MakeRabbitMQPriorityPub, wire.Bind(new(containers.RabbitMQDeployer), new(*containers.RabbitMQPriorityDeployer)), wire.Bind(new(controllers.NotificationPublisher), new(*publisher.RabbitMQPriorityPublisher)))

type PostgresSQSIntegrationTest struct {
	PostgresContainer *containers.PostgresContainer
	SQSContainer      *containers.SQSContainer
	Storage           *storage2.PostgresStorage
	Publisher         *publisher.SQSPublisher
	Engine            *gin.Engine
}

func (app *PostgresSQSIntegrationTest) Cleanup() error {
	if err := app.PostgresContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to cleanup postgres container - %w", err)
	}

	if err := app.SQSContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to terminate sqs container - %w", err)
	}

	return nil
}

type DynamoSQSIntegrationTest struct {
	DynamoContainer *containers.DynamoContainer
	SQSContainer    *containers.SQSContainer
	Storage         *storage.DynamoDBStorage
	Publisher       *publisher.SQSPublisher
	Engine          *gin.Engine
}

func (app *DynamoSQSIntegrationTest) Cleanup() error {
	if err := app.DynamoContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to cleanup dynamo container - %w", err)
	}

	if err := app.SQSContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to terminate sqs container - %w", err)
	}

	return nil
}

type PostgresRabbitMQPriorityIntegrationTest struct {
	PostgresContainer *containers.PostgresContainer
	RabbitMQContainer *containers.RabbitMQContainer
	RabbitMQClient    *publisher.RabbitMQClient
	RabbitMQPubliser  *publisher.RabbitMQPriorityPublisher
	Storage           *storage2.PostgresStorage
	Engine            *gin.Engine
}

func (app *PostgresRabbitMQPriorityIntegrationTest) Cleanup() error {
	if err := app.PostgresContainer.CleanupFn(); err != nil {
		return fmt.Errorf("failed to terminate postgres container - %w", err)
	}

	if err := app.RabbitMQClient.Close(); err != nil {
		return fmt.Errorf("failed to terminate rabbitmq client - %w", err)
	}

	if err := app.RabbitMQContainer.Terminate(); err != nil {
		return fmt.Errorf("failed to terminate rabbitmq container - %w", err)
	}

	return nil
}

type SQSPriorityDeployment struct {
	Client *sqs.Client
	Deploy func() (publisher.PriorityQueues, error)
}

type RabbitMQPriorityDeployment struct {
	Client *publisher.RabbitMQClient
	Deploy func() error
}

func MakePostgresUrlFromContainer(container *containers.PostgresContainer) (storage2.PostgresURL, error) {

	if container == nil {
		return "", fmt.Errorf("postgres container is null")
	}

	return (storage2.PostgresURL)(container.URI), nil
}

func MakeSQSConfigFromContainer(container *containers.SQSContainer) (cfg publisher.SQSConfig, err error) {

	if container == nil {
		return cfg, fmt.Errorf("sqs container is null")
	}

	clientCfg := publisher.SQSClientConfig{BaseEndpoint: &container.URI}
	client, err := publisher.MakeSQSClient(clientCfg)

	if err != nil {
		return cfg, fmt.Errorf("failed to create client - %w", err)
	}

	cfg.Client = client
	cfg.Queues = container.SQSQueues

	return
}

func MakeDynamoConfigFromContainer(container *containers.DynamoContainer) (cfg storage.DynamoClientConfig, err error) {

	if container == nil {
		return cfg, fmt.Errorf("sqs container is null")
	}

	cfg.BaseEndpoint = &container.URI

	return
}

func MakeSQSClient(cfg ConfigLoader) (*sqs.Client, error) {
	clientCfg := publisher.SQSClientConfig{}

	if baseEndpoint, ok := cfg.GetConfigValue(SQS_BASE_ENDPOINT); ok {
		clientCfg.BaseEndpoint = &baseEndpoint
	}

	if region, ok := cfg.GetConfigValue(SQS_REGION); ok {
		clientCfg.Region = &region
	}

	return publisher.MakeSQSClient(clientCfg)
}

func MakeSQSConfig(cfg ConfigLoader) (sqsCfg publisher.SQSConfig, err error) {

	client, err := MakeSQSClient(cfg)

	if err != nil {
		return sqsCfg, err
	}

	queues := GetSQSPriorityQueueUrls(cfg)

	sqsCfg.Client = client
	sqsCfg.Queues = queues

	return
}

func MakeRabbitMKPriorityConfig(client *publisher.RabbitMQClient, queues publisher.PriorityQueues) publisher.RabbitMQPriorityPublisherConfig {
	return publisher.RabbitMQPriorityPublisherConfig{
		Publisher: client,
		Queues:    queues,
	}
}

func MakeEngine(storage3 Storage, pub controllers.NotificationPublisher) *gin.Engine {

	r := gin.Default()
	routes.SetupNotificationRoutes(r, storage3, pub)
	routes.SetupDistributionListRoutes(r, storage3)
	routes.SetupUsersRoutes(r, storage3)

	return r
}

func GetSQSPriorityQueueNames(cfg ConfigLoader) (queues publisher.PriorityQueues) {

	if low, ok := cfg.GetConfigValue(SQS_PRIORITY_LOW_NAME); ok {
		queues.Low = &low
	}

	if medium, ok := cfg.GetConfigValue(SQS_PRIORITY_MEDIUM_NAME); ok {
		queues.Medium = &medium
	}

	if high, ok := cfg.GetConfigValue(SQS_PRIORITY_HIGH_NAME); ok {
		queues.High = &high
	}

	return
}

func GetSQSPriorityQueueUrls(cfg ConfigLoader) (queues publisher.PriorityQueues) {

	if low, ok := cfg.GetConfigValue(SQS_PRIORITY_LOW_URL); ok {
		queues.Low = &low
	}

	if medium, ok := cfg.GetConfigValue(SQS_PRIORITY_MEDIUM_URL); ok {
		queues.Medium = &medium
	}

	if high, ok := cfg.GetConfigValue(SQS_PRIORITY_HIGH_URL); ok {
		queues.High = &high
	}

	return
}

func GetRabbitMQUrl(cfg ConfigLoader) (publisher.RabbitMQURL, error) {

	url, ok := cfg.GetConfigValue(RABBITMQ_URL)

	if !ok {
		return "", fmt.Errorf("rabbitmq url %s not found", RABBITMQ_URL)
	}

	return publisher.RabbitMQURL(url), nil
}

func GetRabbitMQQueues(cfg ConfigLoader) (queues publisher.PriorityQueues) {

	if low, ok := cfg.GetConfigValue(RABBITMQ_PRIORITY_LOW_QUEUE); ok {
		queues.Low = &low
	}

	if medium, ok := cfg.GetConfigValue(RABBITMQ_PRIORITY_MEDIUM_QUEUE); ok {
		queues.Medium = &medium
	}

	if high, ok := cfg.GetConfigValue(RABBITMQ_PRIORITY_HIGH_QUEUE); ok {
		queues.High = &high
	}

	return
}

func MakeSQSPriorityQueueDeployment(client *sqs.Client, queues publisher.PriorityQueues) *SQSPriorityDeployment {

	deploy := func() (publisher.PriorityQueues, error) {
		return deployments.MakePriorityQueues(client, queues)
	}

	return &SQSPriorityDeployment{
		Client: client,
		Deploy: deploy,
	}
}

func MakeRabbitMQDeployment(client *publisher.RabbitMQClient, queues publisher.PriorityQueues) *RabbitMQPriorityDeployment {

	deploy := func() error {
		return deployments2.MakeRabbitMQPriorityQueues(*client, queues)
	}

	return &RabbitMQPriorityDeployment{
		Client: client,
		Deploy: deploy,
	}
}

func GetPostgresUrl(cfg ConfigLoader) (storage2.PostgresURL, error) {
	url, ok := cfg.GetConfigValue(POSTGRES_URL)

	if !ok {
		return "", fmt.Errorf("%s is not set", POSTGRES_URL)
	}

	return storage2.PostgresURL(url), nil
}

func MakeDynamoClientConfig(cfg ConfigLoader) (dynamoCfg storage.DynamoClientConfig) {

	if baseEndpoint, ok := cfg.GetConfigValue(DYNAMO_BASE_ENDPOINT); ok {
		dynamoCfg.BaseEndpoint = &baseEndpoint
	}

	if region, ok := cfg.GetConfigValue(DYNAMO_REGION); ok {
		dynamoCfg.Region = &region
	}

	return
}
